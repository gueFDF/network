对象创建要做到线程安全，唯一的要求就是在构造期间不要泄露 this 指针

- 不要在构造函数中注册回调
- 不要在构造函数中把 this 指针传给跨线程对象
- 即便在最后一行也不行

eg:

```cpp
class Foo : public Observer
{
public:
    Foo(Observable*s)
    {
        s->register_(this);  //错误，线程不安全
    }
};
```

正确方法：

```cpp
class Foo : public Observer
{
public:
    Foo();
    void observer(Obersver*s)
    {
        s->register_(this);
    }
};
Foo*pFoo=new Foo;
Observable* s=getSubject();
pFoo->observe(s);  //二段式构造，或者直接写  s->register_(pFoo);
```

一个函数如果要锁住相同类型的多个对象，为了保证始终按相同的顺序加锁，我们可以比较 mutex 对象的地址，始终先加锁地址较小的 mutex

# 原始指针不妥

引入另外一层间接性，用对象来管理共享资源

C++ 里可能出现的内存问题

1. 缓冲区溢出
2. 空悬指针、野指针
3. 重复释放
4. 内存泄露
5. 不配对的 new/delete
6. 内存碎片

如果多个线程读写同一个 shared_ptr，正确的做法使用 mutex 保护

# 对象池

获得一个指向当前指针的 share_ptr< >

```cpp
class abc: public enable_shared_from_this<abc>
{
public:
    int a;
    abc(int b) : a(b) {}
    shared_ptr<abc> show()
{
        return shared_from_this();
    }
};
```


小结
1. 原始指针暴露给多个线程往往会造成race condition或额外的负担
2. 统一的share_ptr/scoped_ptr来管理对象的生命周期，在多线程中尤为重要。
3. share_ptr 是值语意，当心意外延长对象的生命期
4. weak_ptr 是share_ptr的好搭档，可以用作弱回调，对象池